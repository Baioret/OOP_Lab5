# OOP_Lab5
Лабораторная работа №5 «Жизненный цикл объектов C++ и виртуальность» 

Тип приложения: консольное; язык: c++.

Определение и реализация тестовых классов, написание программы, иллюстрирующей их использование. Лабораторная работа должна включать несколько программ, по мере изучения соответствующих понятий из лекционного курса, не стоит пытаться писать все сразу в одну программу и строго последовательно.

- Определения
    - [ ]  перекрываемых методов (показать на примере случай, когда вызывается перекрываемый метод, а когда наследуемый)
    - [ ]  виртуальных методов, в т.ч. деструкторов (показать на примере, когда вызывается наследуемый виртуальный метод, а когда базовый)
- Реализация
    - [ ]  проверки на принадлежность некоторому классу
    - [ ]  безопасного приведения типов (dynamic_cast)
    - [ ]  опасного приведения типов (вручную)
- Передача объектов как параметров в функции и возвращения объектов как результата из функции, контроль их жизненного цикла
- Умные указатели unique_ptr и shared_ptr, их влияние на жизненный цикл объектов

В рамках лабораторной работы необходимо написать достаточно примеров, чтобы разобраться и понимать, например, суть того, что будет, если:

- [ ]  создать в классе-предке ~~виртуальный конструктор~~ и виртуальный деструктор, зачем нужен виртуальный деструктор и как он работает?
- [ ]  в методе1 базового класса вызывается метод2, который определен в этом же классе как невиртуальный, у класса-потомка метод2 переопределен: что происходит при вызове метода1 у класса-потомка?
- [ ]  в методе1 базового класса вызывается метод2, который определен в этом же классе как виртуальный, у класса-потомка метод2 переопределен: что происходит при вызове метода1 у класса-потомка?
- [ ]  в базовом классе объявить метод невиртуальный, а в классе-потомке объявить метод с таким же именем: какой метод будет вызываться при обращении к объекту через указатель на базовый класс, через указатель на класс-потомок?
- [ ]  в базовом классе объявить метод виртуальный, а в классе-потомке объявить метод с таким же именем: какой метод будет вызываться при обращении к объекту через указатель на базовый класс, через указатель на класс-потомок?

Проиллюстрировать примерами кода и уметь давать ответы на следующие вопросы:

- [ ]  Зачем нужны виртуальные методы? Зачем может понадобиться хранить объект не в указателе на свой собственный класс, а указателе на класс-предок?
- [ ]  Зачем нужна проверка на принадлежность некоторому классу?
- [ ]  Зачем и в каких случаях требуется производить безопасное приведение типов? В каком случае может понадобиться вызвать метод потомка для объекта, который лежит в переменной предка?

Для проверки на принадлежность некоторому классу необходимо реализовать:

- [ ]  базовый виртуальный метод string classname(), перекрыть его в потомках, проверить работу и показать, какие проблемы возникают при его использовании;
- [ ]  базовый виртуальный метод bool isA(string classname), перекрыть его в потомках и показать отличие от метода classname.

Продемонстрировать опасное приведение типов и предварительную проверку типа с помощью реализованного метода isA. Продемонстрировать использование стандартных средств языка (dynamic_cast в c++ или аналог на используемом языке).

Для проверки механизма передачи объектов как параметров в функции необходимо написать три функции:

void func1(Base  obj) { ... };

void func2(Base *obj) { ... };

void func3(Base &obj) { ... };

Далее необходимо создать простой класс Base и его потомок Desc и реализовать в каждом из них три конструктора и по одному деструктору (в каждой из трех функций и во всех конструкторах и деструкторе должен быть отладочный вывод в консоль!):

Base() { ... };

Base(Base *obj) { ... };

Base(Base &obj) { ... };

~Base() { ... };

Desc() { ... };

Desc(Desc *obj) { ... };

Desc(Desc &obj) { ... };

~Desc() { ... };

После этого необходимо создавать объекты классов Base и Desc, и передавать их в каждую из трех функций, объясняя при этом, когда и почему вызывается какой конструктор или деструктор. Необходимо уметь объяснять достоинства и недостатки каждого из вариантов.

Для проверки механизма возврата объектов из функции необходимо написать три функции:

Base func1() { ... };

Base* func2() { ... };

Base& func3() { ... };

Затем необходимо помещать результат вызова каждой из этих трёх функций в локальную переменную и объяснять наблюдаемый отладочный вывод (показывающий последовательность создания и удаления объектов). Необходимо уметь объяснять достоинства и недостатки каждого из вариантов, в том числе уметь идентифицировать неправильную работу с памятью.

Для изучения умных указателей необходимо создать объекты, управляемые с помощью unique_ptr и shared_ptr (с помощью make_unique и make_shared и/или без них), продемонстрировать, как они влияют на время жизни объекта, которым управляют.
